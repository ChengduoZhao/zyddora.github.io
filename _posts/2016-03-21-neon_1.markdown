---
layout:     post
title:      "ARM NEON编程概述"
subtitle:   ""
date:       2016-03-20 13:46:00
author:     "Orchid"
header-img: "img/post-bg-img.jpg"
tags:
    - ARM
    - NEON
---
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

> 本文旨在介绍ARMv7开始增加的一项advanced SIMD extension——NEON技术。有助于帮助读者理解NEON概况，提供的实例分析有助于迅速上手NEON编程。阅读此文要求读者有基本的**C/C++经验**及**汇编代码**经验，若没有也没关系，多理解查阅资料即可。Good luck~!

### Catalog

1. [SIMD及NEON概览](#simdneon)
2. [NEON架构（寄存器/数据类型/指令集）](#neon)
3. [NEON编程基础](#section-2)
4. [NEON使用技巧](#section-3)
5. [参考文献](#section-4)

## SIMD及NEON概览

### **SIMD**

**Single Instruction Multiple Data (SIMD)**顾名思义就是“一条指令处理多个数据（一般是以2为底的指数数量）”的**并行处理**技术，相比于“一条指令处理几个数据”，运算速度将会大大提高。它是Michael J. Flynn在1966年定义的四种计算机架构之一（根据指令数与数据流的关系定义，其余还有SISD、MISD、MIMD）。

**许多程序需要处理大量的数据集，而且很多都是由少于32bits的位数来存储的。**比如在视频、图形、图像处理中的8-bit像素数据；音频编码中的16-bit采样数据等。在诸如上述的情形中，很可能**充斥着大量简单而重复的运算，且少有控制代码的出现**。因此，**SIMD就擅长为这类程序提供更高的性能**，比如下面几类：

- Block-based data processing.
- Audio, video, and image processing codes.
- 2D graphics based on rectangular blocks of pixels.
- 3D graphics.
- Color-space conversion.
- Physics simulations.

在32-bit内核的处理器上，如Cortex-A系列，如果不采用SIMD则会将大量时间花费在处理8-bit或16-bit的数据上，但是处理器本身的ALU、寄存器、数据深度又是主要为了32-bit的运算而设计的。**因此NEON应运而生。**

### **NEON**

NEON就是一种基于SIMD思想的ARM技术，相比于ARMv6或之前的架构，**NEON结合了64-bit和128-bit的SIMD指令集，提供128-bit宽的向量运算(vector operations)。**NEON技术从ARMv7开始被采用，目前可以在ARM Cortex-A和Cortex-R系列处理器中采用。

NEON在Cortex-A7、Cortex-A12、Cortex-A15处理器中被设置为默认选项，但是在其余的ARMv7 Cortex-A系列中是可选项。NEON与VFP共享了同样的寄存器，但它具有自己独立的执行流水线。

---

## **NEON架构（数据类型/寄存器/指令集）**

### **NEON支持的数据类型**

- 32-bit single precision floating-point  32-bit单精度浮点数；
- 8, 16, 32 and 64-bit unsigned and signed integers   8, 16, 32 and 64-bit无符号/有符号整型；
- 8 and 16-bit polynomials  8 and 16-bit多项式。

NEON数据类型说明符：

- Unsigned integer U8 U16 U32 U64
- Signed integer S8 S16 S32 S64
- Integer of unspecified type I8 I16 I32 I64
- Floating-point number F16 F32
- Polynomial over {0,1} P8

注：F16不适用于数据处理运算，只用于数据转换，仅用于实现半精度体系结构扩展的系统。

多项式算术在实现某些加密、数据完整性算法中非常有用。

### **NEON寄存器（重点）**

![img](/img/in-post/neon_reg_bank.jpg)

**NEON寄存器有几种形式：**

- 16×128-bit寄存器(Q0-Q15)；
- 或32×64-bit寄存器(D0-D31)
- 或上述寄存器的组合。

注：**每一个Q0-Q15寄存器映射到一对D寄存器。**

**寄存器之间的映射关系：**

- D<2n> 映射到 Q<n> 的最低有效半部；
- D<2n+1> 映射到 Q<n> 的最高有效半部；

**结合NEON支持的数据类型，NEON寄存器有如下图的几种形态：**

![img](/img/in-post/neon_reg.jpg)

**NEON 数据处理指令可分为：**

- **Normal instructions** can operate on any vector types, and produce result vectors the same
size, and usually the same type, as the operand vectors.
- **Long instructions** operate on doubleword vector operands and produce a quadword vector
result.（操作双字vectors，生成四倍长字vectors） The result elements are usually twice the width of the operands, and of the same type.（结果的宽度一般比操作数加倍，同类型） Long instructions are specified using an L appended to the instruction.（在指令中加L）
- **Wide instructions** operate on a doubleword vector operand and a quadword vector
operand, producing a quadword vector result.（操作双字 + 四倍长字，生成四倍长字） The result elements and the first operand are twice the width of the second operand elements.（结果和第一个操作数都是第二个操作数的两倍宽度） Wide instructions have a W appended to the instruction.（在指令中加W）
- **Narrow instructions** operate on quadword vector operands, and produce a doubleword
vector result.（操作四倍长字，生成双字） The result elements are usually half the width of the operand elements.（结果宽度一般是操作数的一半） Narrow instructions are specified using an N appended to the instruction.（在指令中加N）
- **Saturating variants**
  * ARM中的饱和算法：
    + 对于有符号饱和运算，如果结果小于 –2^n，则返回的结果将为 –2^n；
    + 对于无符号饱和运算，如果整个结果将是负值，那么返回的结果是 0；如果结果大于 2^n – 1，则返回的结果将为 2^n – 1；
  * NEON中的饱和算法：通过在V和指令助记符之间使用Q前缀可以指定饱和指令，原理与上述内容相同。


---

## 通用YUV422I旋转0/180算法

### **解决思路**

旋转0°、180°较90°、270°更简单，仅涉及行上的像素点的转换（最少2*1个像素点）。

### **YUV422I旋转180°示意**

![img](/img/in-post/rot180.jpg)

观察可发现：

- 旋转前的所有YUV信息都有用；
- 旋转后的每行Y信息逆置，UV信息则需要推算，推算思路与上述类似；
- 旋转前后的图像规格不变，仍为`(width * 2) * height`；

旋转0°的本质：

- 图像数据的拷贝；

旋转180°的C程序框架：

```cpp
const unsigned char *src_y = src; /* dst_1_1指向旋转前1-1处的指针 */
unsigned char *dst_y = dst_1_1; /* dst_1_1指向旋转后1-1处的指针 */

for (int i = 0; i < height; ++i) {
  src = src_y;
  dst = dst_y;
  for (int j = 0; j < doublewidth / 4) { /* 假设一次处理每行相邻4个YUYV信息 */
    // 移动Y信息
    // 计算新的UV信息

    src += 4; /* 更新内循环的指针 */
    dst -= 4;
  }
  src_y += doublewidth; /* 更新外循环的指针 */
  dst_y -= doublewidth;
}
```

---

## 完善算法以支持不规则尺寸图像的旋转

上述算法仅是一个基础版本，对于不规则的行列数的图像是不支持的，目前基本算法的局限：

1. 若上述算法一次处理每行多个YUYV信息块（即大于4，如8、16、32等），则存在每行的尾数；
2. 旋转90°/270°算法仅支持高度height为2的倍数；

处理问题1的思路：

可以确定的是YUV422I格式的图像的宽度一定是4的倍数（以YUYV为一组信息），因此不论一次处理每行YUYV块的个数是多少（4、8、16、32等），剩余的YUYV信息一定也是4的整数倍，故对尾数按照以4为行上一组的单位来处理。

处理问题2的思路：

YUV422I格式图像旋转90°/270°，若原图高度为奇数，则对旋转后的宽度造成影响。故此情况，需要在转换过程中进行补齐，可以直接存入255代替缺失的高度。

---

## 更加省时的图像旋转

> 一般地，图像呈现局部相关性，上下左右相邻的像素值相关度很高。

可以发现，旋转算法存在着不少用于计算新UV信息的计算量。但是对于性能优化来说，**有时节省资源与编码效果是互补的关系，以一方的牺牲来换取另一方的提升**，其实这个原则在很多地方都适用，重点在于程序要解决的主要矛盾是什么。那么，**如果对图片质量的需求并不高，就将邻近的UV信息直接复制，以节省掉计算UV的时间，将会带来很大的增益**。

### 推导证明“直接复制UV”的可行性

$$
256\cdot \begin{bmatrix} R\\ G\\ B\end{bmatrix} = 
\begin{bmatrix}298 & 0 & 409\\ 298 & -100 & -208\\ 298 & 516 & 0\end{bmatrix}
\begin{bmatrix}Y-16\\ U-128\\ V-128\end{bmatrix}\\ \\ \\

256^{2}\begin{bmatrix}Y\\ U\\ V\end{bmatrix} = 
256\begin{bmatrix}66 & 129 & 25\\ -38 & -74 & 112\\ 112 & -94 & -18\end{bmatrix}
\begin{bmatrix}298 & 0 & 409\\ 298 & -100 & -208\\ 298 & 516 & 0\end{bmatrix}
\begin{bmatrix}R\\ G\\ B\end{bmatrix} + 256^{2}
\begin{bmatrix}16\\ 128\\ 128\end{bmatrix}\\ \\ \\

256\begin{bmatrix}Y\\ U\\ V\end{bmatrix} = 
\begin{bmatrix}256.09 & 0 & 0.63\\ 0 & 254.66 & -0.59\\ 0 & 0.44 & 255.31\end{bmatrix}
\begin{bmatrix}Y-16\\ U-128\\ V-128\end{bmatrix} + 
256\begin{bmatrix}16\\ 128\\ 128\end{bmatrix}
$$

从推导的结果很容易发现，最终式子的系数矩阵主对角线绝对占优，因此YUV->RGB->YUV整个过程更像是YUV的直接“复制”。

下图是用“直接复制UV”的方法做的图像旋转的实验。

![img](/img/in-post/cont1.JPG)
![img](/img/in-post/cont2.JPG)

可以看到旋转90°后的图像除了高频部分有些杂乱模糊外（注意图中的几个圆圈字母边缘有些模糊，由于是笔者截图后的结果，所以计算机可能做了些处理，减小了前后的差异性），其他表现都不错。这证明直接复制UV的方法某种意义上也是可行的。

---